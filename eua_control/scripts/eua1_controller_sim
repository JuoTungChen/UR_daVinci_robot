#!/usr/bin/env python

from sensor_msgs.msg import JointState
import dynamixel
import itertools
import numpy as np
import reflexxes
import rospy


class EUA1ControllerSim(object):
    def __init__(self):
        self.loop_rate_hz = 100.0

        # We order the supplied device ID's according to this sequence of joint
        # names which corresponds to the kinematic chain
        self.joint_names = ('roll', 'wrist', 'jaw1', 'jaw2')
        prefix = rospy.get_param('~prefix', '')
        self.joint_names_prefixed = [prefix + n for n in self.joint_names]
        self.joint_device_mapping = rospy.get_param('~joint_device_mapping')
        self.joint_device_mapping.update({v: k for k, v in self.joint_device_mapping.iteritems()})  # reverse mapping
        self.device_ids = tuple(self.joint_device_mapping[n] for n in self.joint_names)  # same order as joint_names

        # Transmission/coupling matrix K
        t0 = 1.5     # motor-to-disc transmission (for all motors)
        t1 = 1.5632  # roll disc-to-joint transmission
        t2 = 1.0186  # wrist disc-to-joint transmission
        t3 = 1.2177  # grasper jaw disc-to-joint transmission (the same for both jaws)
        w = 0.6089   # coupling between wrist and grasper jaws (the same for both jaws)
        self.K = t0 * np.array([
            [  t1,  0,     0,   0   ],
            [  0,   t2,    0,   0   ],
            [  0,   t2*w, -t3,  0   ],
            [  0,  -t2*w,  0,   t3  ],
        ])

        # Trajectory generation
        self.tg = reflexxes.extra.PositionTrajectoryGenerator(
            4,                        # number of DOF
            1.0 / self.loop_rate_hz,  # period
            [2 * np.pi] * 4,          # max vel.
            [8 * np.pi] * 4,          # max acc.
            [80 * np.pi] * 4          # max jerk
        )
        self.tg.flags.SynchronizationBehavior = reflexxes.RMLPositionFlags.NO_SYNCHRONIZATION

        # Calibration offset (default to zero at servo center position)
        self.servo_calibration_offset = np.full(4, np.radians(150))

        # Current state of the "simulated" EUA/tool
        self.current_position_servo = np.full(4, np.radians(150))
        self.current_velocity_servo = np.zeros(4)

        self.trajectory = None

        self.pub_joint = rospy.Publisher('joint_states', JointState, queue_size=1)
        self.pub_servo = rospy.Publisher('servo_states', JointState, queue_size=1) if rospy.get_param('~publish_servo_states', False) else None
        self.subscribers = [
            rospy.Subscriber('move_joint', JointState, self.init_trajectory),
            rospy.Subscriber('servo_joint', JointState, self.set_joint_goal_direct),
        ]

        self.state_update_callbacks = []
        self.trajectory_end_callback = None

    def read_servo_state(self):
        s = JointState(position=self.current_position_servo.copy(), velocity=self.current_velocity_servo.copy())
        s.header.stamp = rospy.Time.now()

        # Subtract calibration offset from servo positions
        s.position -= self.servo_calibration_offset

        return s

    def compute_joint_state(self, servo_state):
        s = JointState()
        s.header.stamp = servo_state.header.stamp
        s.name = self.joint_names_prefixed
        s.position = self.K.dot(servo_state.position)
        s.velocity = self.K.dot(servo_state.velocity)
        return s

    def write_joint_goal(self, pos_joint_next):
        # Compute corresponding servo angles through coupling/gearing
        pos_servo_next = np.linalg.solve(self.K, pos_joint_next)

        # Add calibration offset to servo command
        pos_servo_next += self.servo_calibration_offset

        self.current_position_servo = pos_servo_next

    def set_trajgen_target(self, m):
        # Map names to servo IDs
        msg_dev_id = [self.joint_device_mapping[n] for n in m.name]

        # Cache reference to these values while iterating (they are C++ types
        # exposed to Python opaquely)
        target_position = self.tg.target_position
        target_velocity = self.tg.target_velocity

        for i, dev_id in enumerate(self.device_ids):
            if dev_id in msg_dev_id:
                j = msg_dev_id.index(dev_id)
                target_position[i] = m.position[j]
                target_velocity[i] = m.velocity[j] if m.velocity else 0

        # rospy.loginfo("New target:\n\t{} (servo)\n\t{} (joint)".format(
        #     np.linalg.solve(self.K, target_position),
        #     np.array(target_position)))

    def set_joint_goal_direct(self, m):
        """Set servo set-point directly without trajectory generation
        """
        if self.trajectory:
            rospy.logwarn("Ignoring direct joint goal: already moving along trajectory")
            return

        if not m.name or not m.position:
            rospy.logwarn("Bad input (name or position fields empty)")
            return

        # Update trajectory generator target so that future trajectories starts
        # from the correct initial position
        self.set_trajgen_target(m)

        # Write the target directly to servos without generating the actual
        # trajectory
        self.write_joint_goal(self.tg.target_position.tolist())

    def init_trajectory(self, m, trajectory_end_callback=None):
        """Set a joint-space trajectory setpoint for the given servos
        """
        if not m.name or not m.position:
            rospy.logwarn("Bad input (name or position fields empty)")
            return

        self.set_trajgen_target(m)
        self.trajectory_end_callback = trajectory_end_callback
        self.trajectory = self.tg.trajectory()

    def step_trajectory(self):
        try:
            pos_joint_next = self.trajectory.next()[0]
            self.write_joint_goal(pos_joint_next)
        except StopIteration:
            self.trajectory = None

            if self.trajectory_end_callback:
                self.trajectory_end_callback()
                self.trajectory_end_callback = None

    def stop_trajectory(self):
        self.tg.target_position[:] = self.tg.current_position
        self.tg.target_velocity.fill(0)
        self.trajectory = self.tg.trajectory()

    def run(self):
        rospy.loginfo("Starting servo loop")
        rate = rospy.Rate(self.loop_rate_hz)

        try:
            while not rospy.is_shutdown():
                servo_state = self.read_servo_state()
                joint_state = self.compute_joint_state(servo_state)

                if self.trajectory:
                    self.step_trajectory()

                if self.pub_servo is not None:
                    self.pub_servo.publish(servo_state)

                self.pub_joint.publish(joint_state)

                for f in self.state_update_callbacks:
                    f(servo_state, joint_state)

                rate.sleep()  # FIXME: check that loop rate is kept
        except (KeyboardInterrupt, rospy.ROSInterruptException):
            pass


if __name__ == '__main__':
    rospy.init_node('eua1_sim', disable_signals=True)
    controller = EUA1ControllerSim()
    controller.run()
