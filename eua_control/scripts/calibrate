#!/usr/bin/env python

from __future__ import division, print_function

from eua_control import EUAController
from sensor_msgs.msg import JointState
import dynamixel
import numpy as np
import reflexxes
import rospy
import threading


ROLL, WRIST, JAW1, JAW2 = range(4)


class EUACalibrator(object):
    def __init__(self, controller):
        self.c = controller

        controller.tg.max_velocity = [np.pi / 4] * 4
        controller.tg.max_acceleration = [2 * np.pi] * 4
        controller.tg.max_jerk = [20 * np.pi] * 4

        controller.servo_calibration_offset = np.zeros(4)

        self.motor_limits = [(dev.read_param_single('cw_angle_limit'), dev.read_param_single('ccw_angle_limit')) for dev in controller.chain.devices]
        lower = controller.K.dot([lim[0] for lim in self.motor_limits])
        upper = controller.K.dot([lim[1] for lim in self.motor_limits])
        self.motor_upper_limits_in_joint_space = controller.K.dot([lim[1] for lim in self.motor_limits])
        self.motor_limits_in_joint_space = zip(lower, upper)

        self.calibrating_joint = None

        controller.state_update_callbacks.append(self.on_state_change)

        self.servo_state = None
        self.joint_state = None

    def on_state_change(self, servo_state, joint_state):
        self.servo_state = servo_state
        self.joint_state = joint_state

        if self.calibrating_joint is None:
            return

        j = self.calibrating_joint
        name = self.c.joint_names[j]

        if j == ROLL:
            LOAD_THRESHOLD = 0.18  # FIXME: hardcoded servo load thresholds
        elif j == WRIST:
            LOAD_THRESHOLD = 0.14
        else:  # JAW[1,2]
            LOAD_THRESHOLD = 0.13

        if (self.direction == 1 and servo_state.effort[j] < -LOAD_THRESHOLD) or (self.direction == 0 and servo_state.effort[j] > LOAD_THRESHOLD):
            rospy.loginfo("Found '{}' {} joint limit at {:.1f} deg (servo) / {:.1f} deg (joint) - servo load: {:.3f}".format(
                name,
                'upper' if self.direction else 'lower',
                round(np.degrees(servo_state.position[j]), 1),
                round(np.degrees(joint_state.position[j]), 1),
                round(servo_state.effort[j], 3)))

            self.tool_limits_servo[j][self.direction] = servo_state.position[j]
            self.tool_limits_joint[j][self.direction] = joint_state.position[j]

            # Set target=current for this joint
            self.c.stop_trajectory(JointState(name=[name]))
            self.calibrating_joint = None

    def calibrate_joint(self, j):
        # TODO: Set offset via. service call and "move to home position"

        name = self.c.joint_names[j]

        trajectory_end_event = threading.Event()

        def wait_joint(j):
            while self.calibrating_joint == j and not rospy.is_shutdown():
                rospy.sleep(0.1)

        def do_move():
            target_position = self.motor_limits_in_joint_space[j][self.direction]
            rospy.loginfo("Moving toward '{}' {} servo limit at {:.1f} deg (servo) / {:.1f} deg (joint)".format(
                    name,
                    'upper' if self.direction else 'lower',
                    round(np.degrees(self.motor_limits[j][self.direction]), 1),
                    round(np.degrees(target_position), 1)))
            self.c.init_trajectory(JointState(name=[name], position=[target_position]))
            wait_joint(j)

        if j == ROLL or j == WRIST:
            for direction in [1, 0]:
                self.calibrating_joint = j
                self.direction = direction
                do_move()

            # Compute offset and move to zero
            self.servo_calibration_offset[j] = self.tool_limits_servo[j][0] + (self.tool_limits_servo[j][1] - self.tool_limits_servo[j][0]) / 2
            self.joint_calibration_offset[j] = self.tool_limits_joint[j][0] + (self.tool_limits_joint[j][1] - self.tool_limits_joint[j][0]) / 2

            self.c.init_trajectory(JointState(
                    name=[name],
                    position=[self.joint_calibration_offset[j]]),
                    lambda s: trajectory_end_event.set())

        elif j == JAW1:
            self.calibrating_joint = j
            self.direction = 1
            do_move()

            # set known limit of LND
            # limit_position_joint = self.joint_state.position[:]
            limit_position_joint = [0, 0, 0, 0]
            limit_position_joint[j] = np.radians(115)  # 115

            print("self.servo_state.position: {}".format(self.servo_state.position))
            print("self.joint_state.position: {}".format(self.joint_state.position))


            # find corresponding servo state
            limit_position_servo = np.linalg.solve(self.c.K, limit_position_joint)

            print("limit_position_joint: {}".format(limit_position_joint))
            print("limit_position_servo: {}".format(limit_position_servo))

            # return

            # ... and that is the offset to zero
            # self.servo_calibration_offset[j] = self.servo_state.position[j] - limit_position_servo[j]
            # self.joint_calibration_offset[j] = self.joint_state.position[j] - limit_position_joint[j]

            self.servo_calibration_offset[j] = self.servo_state.position[j] - limit_position_servo[j]
            self.joint_calibration_offset[j] = self.joint_state.position[j] - limit_position_joint[j]

            self.c.init_trajectory(JointState(
                    name=[name],
                    position=[self.joint_calibration_offset[j] ]),
                    lambda s: trajectory_end_event.set())

        elif j == JAW2:
            self.calibrating_joint = j
            self.direction = 0
            do_move()

            # set known limit of LND
            current_position_joint = [0, 0, 0, 0]
            current_position_joint[j] = np.radians(100)

            # find corresponding servo state
            current_position_servo = np.linalg.solve(self.c.K, current_position_joint)

            # ... and that is the offset to zero
            self.servo_calibration_offset[j] = current_position_servo[j]
            self.joint_calibration_offset[j] = current_position_joint[j]

            self.c.init_trajectory(JointState(
                    name=[name],
                    position=[self.joint_calibration_offset[j] + np.radians(45)]),
                    lambda s: trajectory_end_event.set())

        rospy.loginfo("Moving '{}' to home position".format(name))
        trajectory_end_event.wait()

    def calibrate(self):
        # idx = [self.c.joint_names.index(n) for n in joints]
        # limits = [self.motor_limits_in_joint_space[i] for i in idx]

        # for i, joint in enumerate(['roll', 'wrist']):
        try:
            # for j in [ROLL, WRIST]:
            for j in [ROLL, WRIST, JAW1]:
            # for j in [JAW2]:
                self.calibrate_joint(j)

            rospy.loginfo("Setting offsets to {} (servo) / {} (joint)".format(self.servo_calibration_offset, self.joint_calibration_offset))
            rospy.set_param('/eua/servo_calibration_offset', [float(x) for x in self.servo_calibration_offset])  # rosparam can't handle 'numpy.float64' type
            rospy.set_param('/eua/joint_calibration_offset', [float(x) for x in self.joint_calibration_offset])

        except (KeyboardInterrupt, rospy.ROSInterruptException):
            # return to initial position on interrupt
            # self.publish_goal(self.device_ids, initial_state.position)
            rospy.logwarn("Calibration interrupted")
        except Exception:
            rospy.signal_shutdown("An error occurred")  # to kill thread
            raise



        # target_position = [abs(lim[1] - lim[0]) / 2 for lim in self.tool_limits]
        # # self.publish_goal(self.device_ids, target_position)
        # self.c.init_trajectory(JointState(name=[name], position=[joint_state.position[i]]))

        # rospy.set_param('limits', {str(i): lim for i, lim in itertools.izip(self.device_ids, self.tool_limits)})

    def run(self):

        self.tool_limits_servo = [[None, None]] * 4
        self.tool_limits_joint = [[None, None]] * 4
        self.servo_calibration_offset = [0] * 4
        self.joint_calibration_offset = [0] * 4
        # self.tool_limits_time = [[None, None]] * 4

        # joints = ('roll', 'wrist')
        # idx = [self.c.joint_names.index(n) for n in joints]
        # limits = [self.motor_limits_in_joint_space[i] for i in idx]

        # for direction in [1, 0]:
        #     target_position = [lim[direction] for lim in self.motor_limits_in_joint_space]
        #     self.c.init_trajectory(JointState(name=[], position=))
        # joints = ('roll', 'wrist')
        self.calibrate()
        # rospy.spin()



if __name__ == '__main__':
    rospy.init_node('eua_calibrate', disable_signals=True)  # rospy is not raising rospy.ROSInterruptException?

    # FIXME: "delete" previous calibration offset via. service call to controller
    try:
        rospy.delete_param('/eua/servo_calibration_offset')
        rospy.delete_param('/eua/joint_calibration_offset')
    except KeyError:
        pass

    controller = EUAController()

    pub = rospy.Publisher('joint_states', JointState, queue_size=1)
    pub_servo = rospy.Publisher('servo_states', JointState, queue_size=1)

    controller.state_update_callbacks.append(lambda servo_state, joint_state: pub.publish(joint_state))
    controller.state_update_callbacks.append(lambda servo_state, joint_state: pub_servo.publish(servo_state))


    calibrator = EUACalibrator(controller)


    t = threading.Thread(target=controller.run)
    t.start()

    calibrator.run()

    rospy.signal_shutdown("Calibration done")
    t.join()


    # calibrator = EUACalibrator()
    # calibrator.run()

#     pub = rospy.Publisher('joint_states', JointState, queue_size=1)

#     sub = rospy.Subscriber('set_position_joint', JointState, controller.init_trajectory)

#     controller.run()











#         rospy.loginfo("Initializing...")

#         self.loop_rate = 100.0  # Hz

#         self.joint_names = ('roll', 'wrist', 'jaw1', 'jaw2')
#         self.joint_device_mapping = rospy.get_param('~joint_device_mapping')
#         self.joint_device_mapping.update({v: k for k, v in self.joint_device_mapping.iteritems()})  # reverse mapping
#         self.device_ids = tuple(self.joint_device_mapping[x] for x in self.joint_names)

#         self.chain = dynamixel.Chain(rospy.get_param('~port'), rospy.get_param('~baud_rate'), self.device_ids)

#         if not self.chain.devices:
#             raise RuntimeError("No devices found")

#         for dev in self.chain.devices:
#             rospy.loginfo("{} -> '{}'".format(dev, self.joint_device_mapping[dev.id])) {}".format(dev), self.joint_device_mapping[dev.id])
#             # print(yaml.dump(dev.dump_cc(), default_flow_style=False))

#         if len(self.joint_names) != len(self.chain.devices) != 4:
#             raise RuntimeError("Not all devices found")

#         self.tg = reflexxes.PositionTrajectoryGenerator(
#             4,                     # number of DOF
#             1.0 / self.loop_rate,  # period
#             [np.pi / 4] * 4,       # max vel.
#             [2 * np.pi] * 4,       # max acc.
#             [20 * np.pi] * 4       # max jerk
#         )

#         servo_state = self.read_servo_state()
#         joint_state = self.compute_joint_state(servo_state)

#         self.tg.selection = [False] * 4
#         self.tg.current_position = joint_state.position
#         self.tg.current_velocity = [0] * 4
#         self.tg.target_position = joint_state.position
#         self.tg.target_velocity = [0] * 4

#         self.trajectory = None


#         # self.active = [False] * n

#         # self.state_hist = []


#     def step_trajectory(self):
#         try:
#             pos_next = self.trajectory.next()[0]

#             for dev, pos in itertools.izip(self.chain.devices, pos_next):
#                 dev.write_param_single('goal_position', pos)
#         except StopIteration:
#             self.trajectory = None

#     def joints_at_limit(self, state, direction):
#         at_limit = []
#         active = self.tg.selection
#         T = 0.18

#         for i, dev_id, d, load in itertools.izip(itertools.count(), self.device_ids, direction. state.load):
#             # if active[i] and ((d == 1 and load < -T) or (d == 0 and load > T)):
#             if active[i] and (load < -T or load > T):
#                 at_limit.append(True)
#             else:
#                 at_limit.append(False)

#         return at_limit

#     def step(self, action):
#         next_action = action
#         state = self.read_servo_state()

#         if action == 'JAWS INIT':
#             self.tg.selection = [False, False, True, True]
#             target_position = [state.position[0], state.position[1], self.motor_limits[2][0], self.motor_limits[3][1]]
#             self.trajectory = self.tg.trajectory(target_position, [0] * 4)
#             next_action 'JAWS FIND LIMIT'
#         elif action == 'JAWS FIND LIMIT':
#             at_limit = joints_at_limit(self, state, direction)

#             for i, limited, pos in itertools.izip(itertools.count(), at_limit, state.position):
#                 if limited:
#                     self.tool_limits[i][self.direction] = pos


#             # [a and b for a, b in zip(x, y)]

#             if self.trajectory:
#                 self.step_trajectory()

#             pass

#         return next_action

#     def run(self):
#         rospy.loginfo("Running calibration")
#         rate = rospy.Rate(self.loop_rate)

#         self.tool_limits = [[None, None]] * 4
#         self.motor_limits = [(dev.get_param_single('cw_angle_limit'), dev.get_param_single('ccw_angle_limit')) for dev in self.chain.devices]
#         self.initial_state = self.read_servo_state()

#         self.tg.selection = [False] * 4
#         self.tg.current_position = self.initial_state.position
#         self.tg.current_velocity = [0] * 4

#         action = 'CALIBRATE_JAWS':

#         try:
#             while not rospy.is_shutdown():
#                 action = self.step(action)
#                 rate.sleep()  # TODO check that loop rate is kept
#         except (KeyboardInterrupt, rospy.ROSInterruptException):
#             pass
#         finally:
#             # disable servo torque
#             for dev in self.chain.devices:
#                 dev.write_param_single('torque_enable', False)


#         # self.motor_limits = [(dev.get_param_single('cw_angle_limit'), dev.get_param_single('ccw_angle_limit')) for dev in self.chain.devices]






# if __name__ == '__main__':
#     rospy.init_node('eua_calibrate', disable_signals=True)
#     controller = EUAController()

#     pub = rospy.Publisher('joint_states', JointState, queue_size=1)
#     controller.joint_state_callbacks.append(pub.publish)

#     sub = rospy.Subscriber('set_position_joint', JointState, controller.init_trajectory)

#     controller.run()






















    # def step(self, msg):
    #     s = self.filter_servo_state_msg(msg)
    #     self.state_hist.append(s)

    #     if not any(self.active):
    #         return

    #     T = 0.18

    #     for i, dev_id, pos, ld in itertools.izip(itertools.count(), self.device_ids, s.position, s.load):
    #         if self.active[i] and ((self.direction == 1 and ld < -T) or (self.direction == 0 and ld > T)):
    #             rospy.loginfo('Found servo #{} {} limit at {:.3f} rad / {:.1f} deg (load: {:.3f})'.format(dev_id, 'upper' if self.direction else 'lower', round(pos, 3), round(math.degrees(pos), 1), ld))
    #             self.tool_limits[i][self.direction] = pos
    #             self.tool_limits_time[i][self.direction] = msg.header.stamp.to_sec()
    #             self.active[i] = False
    #             self.publish_goal_direct([dev_id], [pos])  # set goal for device 'i' to the current position
    #             # self.publish_goal([dev_id], [self.initial_state.position[i]])  # set goal for device 'i' to the current position


        # for direction in [1, 0]:
        #     # self.direction = direction
        #     self.active = [True] * self.ndof
        #     target_position = [lim[direction] for lim in self.motor_limits]


        # try:
        #     while any(self.active) and not rospy.is_shutdown():
        #         state = self.read_servo_state()
        #         self.state_hist.append(state)

        #         if self.trajectory:
        #             self.step_trajectory()

        #         rate.sleep()  # TODO check that loop rate is kept
        # except (KeyboardInterrupt, rospy.ROSInterruptException):
        #     pass
        # finally:
        #     # disable servo torque
        #     for dev in self.chain.devices:
        #         dev.write_param_single('torque_enable', False)

        # while not self.state_hist:
        #     rospy.sleep(0.5)

        # self.initial_state = self.state_hist[-1]
        # self.tool_limits = [[None, None] for i in self.device_ids]
        # self.tool_limits_time = [[None, None] for i in self.device_ids]

        # # for direction in [1]:
        # for direction in [1, 0]:
        #     self.direction = direction
        #     self.active = [True] * self.ndof
        #     target_position = [lim[direction] for lim in self.motor_limits]
        #     self.publish_goal(self.device_ids, target_position)

        #     try:
        #         while any(self.active) and not rospy.is_shutdown():
        #             rospy.sleep(0.1)
        #     except KeyboardInterrupt:
        #         # return to initial position on interrupt
        #         self.publish_goal(self.device_ids, self.initial_state.position)
        #         rospy.loginfo('Interrupted')
        #         return

        # rospy.loginfo('Calibration done')


        # # move to center position
        # target_position = [lim[0] + (lim[1] - lim[0]) / 2 for lim in self.tool_limits]
        # self.publish_goal(self.device_ids, target_position)

        # # set limits on param server
        # rospy.set_param('limits', {str(i): lim for i, lim in itertools.izip(self.device_ids, self.tool_limits)})

        # rospy.sleep(1)
        # del self.sub_servo_state
        # rospy.sleep(1)
        # self.plot()

    # def plot(self):
    #     import matplotlib.pyplot as plt

    #     ts = [s.stamp for s in self.state_hist]
    #     pos = [m.position for m in self.state_hist]
    #     vel = [m.velocity for m in self.state_hist]
    #     load = [m.load for m in self.state_hist]

    #     # align list lengths
    #     min_len = min(len(l) for l in [ts, pos, vel, load])

    #     for l in [ts, pos, vel, load]:
    #         if len(l) > min_len:
    #             del l[min_len:]

    #     fig, axes = plt.subplots(3, sharex=True)

    #     prop_cycle = plt.rcParams['axes.prop_cycle']
    #     colors = prop_cycle.by_key()['color']

    #     axes[0].plot(ts, pos)
    #     axes[0].set_ylabel('position [rad]')
    #     axes[0].set_ylim((0, 2*math.pi))
    #     # for lim in self.motor_limits:
    #     #     axes[0].axhline(y=lim[0], color='red', linestyle='dashed', linewidth=1)
    #     #     axes[0].axhline(y=lim[1], color='red', linestyle='dashed', linewidth=1)
    #     for lim, c in itertools.izip(self.tool_limits, colors):
    #         axes[0].axhline(y=lim[0], color=c, linestyle='dashed', linewidth=1)
    #         axes[0].axhline(y=lim[1], color=c, linestyle='dashed', linewidth=1)
    #     axes[0].scatter(self.tool_limits_time, self.tool_limits, marker='o', color='red')
    #     axes[0].legend([str(i) for i in self.device_ids])

    #     axes[1].plot(ts, vel)
    #     axes[1].set_ylabel('velocity [rad/s]')
    #     axes[1].legend([str(i) for i in self.device_ids])

    #     axes[2].plot(ts, load)
    #     axes[2].set_ylabel('load')
    #     axes[2].set_xlabel('ROS time')
    #     axes[2].legend([str(i) for i in self.device_ids])

    #     for ax in axes:
    #         for lim in self.tool_limits_time:
    #             ax.axvline(lim[0], color='k', linestyle='dashed', linewidth=1)
    #             ax.axvline(lim[1], color='k', linestyle='dashed', linewidth=1)

    #     for ax in axes[1:]:
    #         axes[0].axhline(y=0, color='k', linewidth=1)

    #     plt.show()


# #!/usr/bin/env python

# from __future__ import division, print_function

# import dynamixel
# from sensor_msgs.msg import JointState
# from std_srvs.srv import Trigger
# import itertools
# import reflexxes
# import rospy
# import numpy as np
# # import yaml


# STATE_IDLE, STATE_TRAJECTORY, STATE_HOMING = range(3)

# HOMING_GRASPER_JAWS, HOMING_WRIST_ROLL = range(2)


# class Homing(object):
#     def __init__(self, dynamixel_chain)
#         self.loop_rate = 100.0  # Hz
#         self.chain = dynamixel_chain
#         n = len(self.chain.devices)
#         self.tg = reflexxes.PositionTrajectoryGenerator(
#             n,                   # number of DOF
#             1.0 / self.loop_rate,  # period
#             [np.pi/4] * n,     # max vel.
#             [2*np.pi] * n,     # max acc.
#             [20*np.pi] * n     # max jerk
#         )


# class EUAController(object):
#     def __init__(self):
#         rospy.loginfo("Initializing...")

#         self.loop_rate = 100.0  # Hz
#         self.device_ids = rospy.get_param('~device_ids', [])
#         self.chain = dynamixel.Chain(rospy.get_param('~port', '/dev/ttyUSB0'), rospy.get_param('~baud_rate', 57600), self.device_ids)

#         if not self.chain.devices:
#             raise RuntimeError("No devices found")

#         if len(self.device_ids) != len(self.chain.devices):
#             raise RuntimeError("Not all devices found")

#         for dev in self.chain.devices:
#             rospy.loginfo("Found {}".format(dev))
#             # print(yaml.dump(dev.dump_cc(), default_flow_style=False))

#         self.joint_names = rospy.get_param('~joint_names', [str(i) for i in self.device_ids])

#         self.device_names = dict(zip(self.device_ids, self.joint_names))
#         self.device_names.update(dict(reversed(i) for i in self.device_names.items()))  # reverse mapping

#         # Transmission/coupling matrix K
#         t0 = 1.5     # motor-to-disc transmission (for all motors)
#         t1 = 1.5632  # roll disc-to-joint transmission
#         t2 = 1.0186  # wrist disc-to-joint transmission
#         t3 = 1.2177  # grasper jaws disc-to-joint transmission
#         w = 0.6089   # coupling between wrist and grasper jaws
#         self.K = t0 * np.array([
#             [  t1,  0,     0,   0   ],
#             [  0,   t2,    0,   0   ],
#             [  0,  -t2*w,  t3,  0   ],
#             [  0,   t2*w,  0,  -t3  ],
#         ])

#         n = len(self.chain.devices)

#         self.tg = reflexxes.PositionTrajectoryGenerator(
#             n,                   # number of DOF
#             1.0 / self.loop_rate,  # period
#             [2*np.pi] * n,     # max vel.
#             [8*np.pi] * n,     # max acc.
#             [80*np.pi] * n     # max jerk
#             # [np.pi/4] * n,     # max vel.
#             # [2*np.pi] * n,     # max acc.
#             # [20*np.pi] * n     # max jerk
#         )

#         servo_state = self.read_servo_state()
#         joint_state = self.compute_joint_state(servo_state)

#         self.tg.selection = [False] * n
#         self.tg.current_position = joint_state.position
#         self.tg.current_velocity = [0] * n
#         self.tg.target_position = joint_state.position
#         self.tg.target_velocity = [0] * n

#         self.pub_servo_states = rospy.Publisher('servo_states', JointState, queue_size=1)
#         self.pub_joint_states = rospy.Publisher('joint_states', JointState, queue_size=1)
#         self.ros_stuff = [
#             rospy.Service('do_homing', Trigger, self.init_homing),
#             rospy.Subscriber('set_position_joint', JointState, self.init_trajectory),
#         ]

#     def read_servo_state(self):
#         s = JointState()

#         for dev in self.chain.devices:
#             if isinstance(dev, dynamixel.device.AX12):
#                 d = dev.read_params(['present_position', 'present_speed', 'present_load'])
#                 s.position.append(d['present_position'])
#                 s.velocity.append(d['present_speed'])
#                 s.effort.append(d['present_load'])
#             elif isinstance(dev, dynamixel.device.MX28_2):
#                 d = dev.read_params(['present_load', 'present_velocity', 'present_position'])
#                 s.position.append(d['present_position'])
#                 s.velocity.append(d['present_velocity'])
#                 s.effort.append(d['present_load'])

#         return s

#     def compute_joint_state(self, servo_state):
#         return JointState(
#             position=self.K.dot(servo_state.position),
#             velocity=self.K.dot(servo_state.velocity)
#         )

#     def publish_state(self, s, kind):
#         s.header.stamp = rospy.Time.now()

#         if kind == 'servo':
#             s.name = [str(i) for i in self.device_ids]
#             self.pub_servo_states.publish(s)
#         elif kind == 'joint':
#             s.name = self.joint_names
#             self.pub_joint_states.publish(s)

#     def init_trajectory(self, msg):
#         # Set a joint-space trajectory setpoint for servos given in msg
#         msg_id = [self.device_names[n] for n in msg.name]  # map names to servo ID

#         selection = self.tg.selection
#         current_position = self.tg.current_position
#         current_velocity = self.tg.current_velocity
#         target_position = self.tg.target_position
#         target_velocity = self.tg.target_velocity

#         for i, dev in enumerate(self.chain.devices):
#             if dev.id in msg_id:
#                 selection[i] = True
#                 j = msg_id.index(dev.id)
#                 target_position[i] = msg.position[j]
#                 target_velocity[i] = msg.velocity[j] if msg.velocity else 0
#             else:
#                 selection[i] = False

#         self.tg.selection = selection
#         self.tg.current_position = current_position
#         self.tg.current_velocity = current_velocity
#         self.trajectory = self.tg.trajectory(target_position, target_velocity)
#         self.state = STATE_TRAJECTORY

#         # rospy.loginfo("New goal:\n  position={}\n  velocity={}".format(target_position, target_velocity))

#     def step_trajectory(self):
#         try:
#             pos_joint_next = self.trajectory.next()[0]
#             # print(('pos_joint_next', pos_joint_next))
#             pos_motor_next = np.linalg.solve(self.K, pos_joint_next)
#             # print(('pos_motor_next', pos_motor_next))

#             for dev, pos in itertools.izip(self.chain.devices, pos_motor_next):
#                 dev.write_param_single('goal_position', pos)
#         except StopIteration:
#             self.state = STATE_IDLE

#     def init_homing(self):
#         servo_limits = [(dev.read_params_single('cw_angle_limit'), dev.read_params_single('ccw_angle_limit')) for dev in self.chain.devices]
#         print(servo_limits)

#         initial_state = self.read_servo_state()
#         # joint_state = self.compute_joint_state(servo_state)

#         self.tg.max_velocity = [np.pi/4] * self.tg.n_dof,     # max vel.
#         self.tg.max_acceleration = [2*np.pi] * self.tg.n_dof,     # max vel.
#         self.tg.max_jerk = [20*np.pi] * self.tg.n_dof,     # max vel.

#         self.tg.selection = [False] * n
#         self.tg.current_position = initial_state.position
#         self.tg.current_velocity = [0] * n
#         self.tg.target_position = initial_state.position
#         self.tg.target_velocity = [0] * n


#         self.trajectory = self.tg.trajectory(target_position, target_velocity)

#         self.state = STATE_HOMING
#         self.homing_state = HOMING_GRASPER_JAWS

#         # self.initial_state = self.state_hist[-1]
#         # self.tool_limits = [[None, None] for i in self.device_ids]
#         # self.tool_limits_time = [[None, None] for i in self.device_ids]

#         # # for direction in [1]:
#         # for direction in [1, 0]:
#         #     self.direction = direction
#         #     self.active = [True] * self.ndof
#         #     target_position = [lim[direction] for lim in self.motor_limits]
#         #     self.publish_goal(self.device_ids, target_position)

#         #     try:
#         #         while any(self.active) and not rospy.is_shutdown():
#         #             rospy.sleep(0.1)
#         #     except KeyboardInterrupt:
#         #         # return to initial position on interrupt
#         #         self.publish_goal(self.device_ids, self.initial_state.position)
#         #         rospy.loginfo('Interrupted')
#         #         return

#     def step_homing(self):
#         for direction in [1, 0]:

#     def act(self, servo_state, joint_state):
#         if self.state == STATE_TRAJECTORY:
#             self.step_trajectory()
#         elif self.state == STATE_HOMING:
#             self.step_homing()
#         # else: do nothing

#     def run(self):
#         rospy.loginfo("Starting servo loop")
#         rate = rospy.Rate(self.loop_rate)
#         self.state = STATE_IDLE

#         try:
#             while not rospy.is_shutdown():
#                 servo_state = self.read_servo_state()
#                 joint_state = self.compute_joint_state(servo_state)

#                 self.act(servo_state, joint_state)

#                 self.publish_state(servo_state, 'servo')
#                 self.publish_state(joint_state, 'joint')

#                 rate.sleep()  # TODO check that loop rate is kept
#         except (KeyboardInterrupt, rospy.ROSInterruptException):
#             pass
#         finally:
#             # disable servo torque
#             for dev in self.chain.devices:
#                 dev.write_param_single('torque_enable', False)


# if __name__ == '__main__':
#     rospy.init_node('eua_control', disable_signals=True)
#     controller = EUAController()
#     controller.run()




# from __future__ import division, print_function

# import dynamixel_msgs.msg
# import dynamixel_msgs.srv
# import itertools
# import math
# import rospy
# import yaml


# class ServoState(object):
#     def __init__(self):
#         self.stamp = None
#         self.position = []
#         self.velocity = []
#         self.load = []

