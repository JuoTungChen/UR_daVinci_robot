#!/usr/bin/env python

from __future__ import division, print_function

from eua_control import EUAController
from sensor_msgs.msg import JointState
import dynamixel
import numpy as np
import reflexxes
import rospy
import threading


ROLL, WRIST, JAW1, JAW2 = range(4)


class EUACalibrator(object):
    def __init__(self, controller):
        self.c = controller

        controller.tg.max_velocity = [np.pi / 4] * 4
        controller.tg.max_acceleration = [2 * np.pi] * 4
        controller.tg.max_jerk = [20 * np.pi] * 4

        controller.servo_calibration_offset = np.zeros(4)

        self.motor_limits = [(dev.read_param_single('cw_angle_limit'), dev.read_param_single('ccw_angle_limit')) for dev in controller.chain.devices]
        lower = controller.K.dot([lim[0] for lim in self.motor_limits])
        upper = controller.K.dot([lim[1] for lim in self.motor_limits])
        self.motor_upper_limits_in_joint_space = controller.K.dot([lim[1] for lim in self.motor_limits])
        self.motor_limits_in_joint_space = zip(lower, upper)

        self.calibrating_joint = None

        controller.state_update_callbacks.append(self.on_state_change)

        self.servo_state = None
        self.joint_state = None

    def on_state_change(self, servo_state, joint_state):
        self.servo_state = servo_state
        self.joint_state = joint_state

        if self.calibrating_joint is None:
            return

        j = self.calibrating_joint
        name = self.c.joint_names[j]

        if j == ROLL:
            LOAD_THRESHOLD = 0.18  # FIXME: hardcoded servo load thresholds
        elif j == WRIST:
            LOAD_THRESHOLD = 0.14
        else:  # JAW[1,2]
            LOAD_THRESHOLD = 0.15

        if (self.direction == 1 and servo_state.effort[j] < -LOAD_THRESHOLD) or (self.direction == 0 and servo_state.effort[j] > LOAD_THRESHOLD):
            rospy.loginfo("Found '{}' {} joint limit at {:.1f} deg (servo) / {:.1f} deg (joint) - servo load: {:.3f}".format(
                name,
                'upper' if self.direction else 'lower',
                round(np.degrees(servo_state.position[j]), 1),
                round(np.degrees(joint_state.position[j]), 1),
                round(servo_state.effort[j], 3)))

            self.tool_limits_servo[j][self.direction] = servo_state.position[j]
            self.tool_limits_joint[j][self.direction] = joint_state.position[j]

            # Set target=current for this joint
            self.c.stop_trajectory()
            self.calibrating_joint = None

    def calibrate_joint(self, j):
        # TODO: Set offset via. service call and "move to home position"

        name = self.c.joint_names[j]

        trajectory_end_event = threading.Event()

        def wait_joint(j):
            while self.calibrating_joint == j and not rospy.is_shutdown():
                rospy.sleep(0.1)

        def do_move():
            target_position = self.motor_limits_in_joint_space[j][self.direction]
            rospy.loginfo("Moving toward '{}' {} servo limit at {:.1f} deg (servo) / {:.1f} deg (joint)".format(
                    name,
                    'upper' if self.direction else 'lower',
                    round(np.degrees(self.motor_limits[j][self.direction]), 1),
                    round(np.degrees(target_position), 1)))
            self.c.init_trajectory(JointState(name=[name], position=[target_position]))
            wait_joint(j)

        if j == ROLL or j == WRIST:
            for direction in [1, 0]:
                self.calibrating_joint = j
                self.direction = direction
                do_move()

            # Compute offset and move to zero
            self.servo_calibration_offset[j] = self.tool_limits_servo[j][0] + (self.tool_limits_servo[j][1] - self.tool_limits_servo[j][0]) / 2
            self.joint_calibration_offset[j] = self.tool_limits_joint[j][0] + (self.tool_limits_joint[j][1] - self.tool_limits_joint[j][0]) / 2

            self.c.init_trajectory(JointState(
                    name=[name],
                    position=[self.joint_calibration_offset[j]]),
                    lambda: trajectory_end_event.set())

        elif j == JAW1 or j == JAW2:
            self.calibrating_joint = j
            self.direction = 1 if j == JAW1 else 0
            do_move()

            # set known limit of LND
            limit_position_joint = [0, 0, 0, 0]  # self.joint_state.position[:]
            limit_position_joint[j] = np.radians(115)

            # find corresponding servo state
            limit_position_servo = np.linalg.solve(self.c.K, limit_position_joint)

            # and that is the offset to zero
            self.servo_calibration_offset[j] = self.servo_state.position[j] - limit_position_servo[j]
            self.joint_calibration_offset[j] = self.joint_state.position[j] - limit_position_joint[j]

            self.c.init_trajectory(JointState(
                    name=[name],
                    position=[self.joint_calibration_offset[j] ]),
                    lambda: trajectory_end_event.set())

        rospy.loginfo("Moving '{}' to home position".format(name))
        trajectory_end_event.wait()

    def calibrate(self):
        try:
            for j in [ROLL, WRIST, JAW1, JAW2]:
                self.calibrate_joint(j)

            rospy.loginfo("Setting offsets to {} (servo) / {} (joint)".format(self.servo_calibration_offset, self.joint_calibration_offset))
            rospy.set_param('/eua/servo_calibration_offset', [float(x) for x in self.servo_calibration_offset])  # rosparam can't handle 'numpy.float64' type
            rospy.set_param('/eua/joint_calibration_offset', [float(x) for x in self.joint_calibration_offset])

        except (KeyboardInterrupt, rospy.ROSInterruptException):
            # return to initial position on interrupt
            # self.publish_goal(self.device_ids, initial_state.position)
            rospy.logwarn("Calibration interrupted")
        except Exception:
            rospy.signal_shutdown("An error occurred")  # to kill thread
            raise

    def run(self):
        self.tool_limits_servo = [[None, None]] * 4
        self.tool_limits_joint = [[None, None]] * 4
        self.servo_calibration_offset = [0] * 4
        self.joint_calibration_offset = [0] * 4
        self.calibrate()

if __name__ == '__main__':
    rospy.init_node('eua_calibrate', disable_signals=True)

    # TODO: "delete" previous calibration offset via. service call to controller
    try:
        rospy.delete_param('/eua/servo_calibration_offset')
        rospy.delete_param('/eua/joint_calibration_offset')
    except KeyError:
        pass

    controller = EUAController()
    calibrator = EUACalibrator(controller)

    t = threading.Thread(target=controller.run)
    t.start()

    calibrator.run()

    rospy.signal_shutdown("Calibration done")
    t.join()
