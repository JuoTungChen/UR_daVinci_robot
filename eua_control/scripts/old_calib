#!/usr/bin/env python

from __future__ import division, print_function

import dynamixel_msgs.msg
import dynamixel_msgs.srv
import itertools
import math
import rospy
import yaml
import threading


class ServoState(object):
    def __init__(self):
        self.position = []
        self.velocity = []
        self.load = []


class Node(object):
    def __init__(self):
        rospy.init_node('eua_calibrate', disable_signals=True)

        # self.device_ids = [1, 2, 3, 4]
        # self.device_ids = [1, 2]
        self.device_ids = [1]
        self.ndof = len(self.device_ids)

        self.active = [False] * self.ndof

        self.state = None

        self.state_hist = []

        self.sub_servo_state = rospy.Subscriber('servo_state', dynamixel_msgs.msg.ServoState, self.on_servo_state)
        self.pub_servo_goal = rospy.Publisher('servo_goal', dynamixel_msgs.msg.ServoGoal, queue_size=1)

        rospy.wait_for_service('get_param')
        self.get_param_proxy = rospy.ServiceProxy('get_param', dynamixel_msgs.srv.GetParam)
        self.get_param = lambda i, name: yaml.safe_load(self.get_param_proxy(i, name).value)

        rospy.wait_for_service('set_param')
        self.set_param_proxy = rospy.ServiceProxy('set_param', dynamixel_msgs.srv.SetParam)
        self.set_param = lambda i, name, val: self.set_param_proxy(i, name, str(val))

        self.motor_limits = [[self.get_param(i, 'cw_angle_limit'), self.get_param(i, 'ccw_angle_limit')] for i in self.device_ids]

        self.lock = threading.Lock()



        # rospy.sleep(1)

        # [math.pi/6] * self.ndof,  # max. vel.
        # [2*math.pi] * self.ndof   # max. acc.

    def publish_goal(self, device_ids, position):
        msg = dynamixel_msgs.msg.ServoGoal()
        msg.header.stamp = rospy.Time.now()
        msg.id = device_ids
        msg.position = position
        self.pub_servo_goal.publish(msg)

    def filter_servo_state_msg(self, msg):
        s = ServoState()

        for dev_id in self.device_ids:
            try:
                i = msg.id.index(dev_id)
                s.position.append(msg.position[i])
                s.velocity.append(msg.velocity[i])
                s.load.append(msg.load[i])
            except ValueError:
                raise RuntimeError("Not getting state of device with id '{}' as expected".format(dev_id))

        return s

    def on_servo_state(self, msg):
        self.state = self.filter_servo_state_msg(msg)

        # self.ts.append(msg.header.stamp.to_sec())
        with self.lock:
            self.state_hist.append(msg)

        if not any(self.active):
            return

        T = 0.18

        for i, dev_id, pos, ld in itertools.izip(itertools.count(), self.device_ids, self.state.position, self.state.load):
            if self.active[i] and ((self.direction == 1 and ld < -T) or (self.direction == 0 and ld > T)):
                rospy.loginfo('Found servo #{} {} limit at {:.3f} rad / {:.1f} deg (load: {:.3f})'.format(dev_id, 'upper' if self.direction else 'lower', round(pos, 3), round(math.degrees(pos), 1), ld))
                self.tool_limits[i][self.direction] = pos
                self.tool_limits_time[i][self.direction] = msg.header.stamp.to_sec()
                self.active[i] = False
                self.publish_goal([dev_id], [pos])  # set goal for device 'i' to the current position

    def find_joint_limits(self):
        while not self.state:
            rospy.sleep(0.5)

        initial_state = self.state
        self.tool_limits = [[None, None] for i in self.device_ids]
        self.tool_limits_time = [[None, None] for i in self.device_ids]

        for direction in [1, 0]:
            self.direction = direction
            self.active = [True]*self.ndof
            target_position = [lim[direction] for lim in self.motor_limits]
            self.publish_goal(self.device_ids, target_position)

            try:
                while any(self.active) and not rospy.is_shutdown():
                    rospy.sleep(0.1)
            except KeyboardInterrupt:
                # return to initial position on interrupt
                self.publish_goal(self.device_ids, initial_state.position)
                rospy.loginfo('Interrupted')
                return

        rospy.loginfo('Calibration done')
        # rospy.loginfo(self.tool_limits)
        target_position = [abs(lim[1] - lim[0]) / 2 for lim in self.tool_limits]
        self.publish_goal(self.device_ids, target_position)

        rospy.set_param('limits', {str(i): lim for i, lim in itertools.izip(self.device_ids, self.tool_limits)})

        rospy.sleep(1)

        with self.lock:
            ts = [m.header.stamp.to_sec() for m in self.state_hist]
            t0 = ts[0]
            ts = [t - t0 for t in ts]
            pos = [m.position[0] for m in self.state_hist]
            vel = [m.velocity[0] for m in self.state_hist]
            load = [m.load[0] for m in self.state_hist]

            min_len = min(len(l) for l in [ts, pos, vel, load])

            for l in [ts, pos, vel, load]:
                if len(l) > min_len:
                    del l[min_len:]

            import matplotlib.pyplot as plt
            fig, axes = plt.subplots(3, sharex=True)
            axes[0].plot(ts, pos)
            axes[1].plot(ts, vel)
            axes[2].plot(ts, load)
            for ax in axes:
                ax.axvline(x=self.tool_limits_time[0][0] - t0)
                ax.axvline(x=self.tool_limits_time[0][1] - t0)
            plt.show()


if __name__ == '__main__':
    node = Node()
    node.find_joint_limits()
